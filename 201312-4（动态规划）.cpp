/**
 * 201312-4 有趣的数
 * 动态规划
 * 将字符串分为6种状态，dp[n][6]
 * 0: 只有数字2
 * 1: 只有2和0，且第一位为2
 * 2: 只有2和3，2在3前
 * 3: 只有2、0、1
 * 4：只有2、0、3
 * 5：含2、0、1、3
 * 长度为n的字符串可由长度为n-1的字符串在末尾添加数字转移得到
 */
#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007

long long dp[1001][6];

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;
    dp[1][0] = 1;
    dp[1][1] = dp[1][2] = dp[1][3] = dp[1][4] = dp[1][5] = 0;
    for (int i = 2; i <= n; i++)
    {
        dp[i][0] = 1;
        // 1: 在0末尾添加0或在1末尾添加0或2
        dp[i][1] = (dp[i - 1][0] + 2 * dp[i - 1][1]) % MOD;
        // 2：在0末尾添加3或在3末尾添加3
        dp[i][2] = (dp[i - 1][0] + dp[i - 1][2]) % MOD;
        // 3：在1末尾添加1或在3末尾添加2、1
        dp[i][3] = (dp[i - 1][1] + 2 * dp[i - 1][3]) % MOD;
        // 4：在1末尾添加3或在2末尾添加0或在4末尾添加0、3
        dp[i][4] = (dp[i - 1][1] + dp[i - 1][2] + 2 * dp[i - 1][4]) % MOD;
        // 5：在3末尾添加3或在4末尾添加1或在5末尾添加1、3
        dp[i][5] = (dp[i - 1][3] + dp[i - 1][4] + 2 * dp[i - 1][5]) % MOD;
    }

    cout << dp[n][5] << endl;

    return 0;
}
